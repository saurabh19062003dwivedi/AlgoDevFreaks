{"ast":null,"code":"/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\n\n/**\r\n * Check if `Child` can be a child of `Ancestor`.\r\n *\r\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\r\n * `never`.\r\n *\r\n * @template {Node} Ancestor\r\n *   Node type.\r\n * @template {Node} Child\r\n *   Node type.\r\n * @typedef {(\r\n *   Ancestor extends Parent\r\n *     ? Child extends Ancestor['children'][number]\r\n *       ? Ancestor\r\n *       : never\r\n *     : never\r\n * )} ParentsOf\r\n */\n\n/**\r\n * @template {Node} [Visited=Node]\r\n *   Visited node type.\r\n * @template {Parent} [Ancestor=Parent]\r\n *   Ancestor type.\r\n * @callback Visitor\r\n *   Handle a node (matching `test`, if given).\r\n *\r\n *   Visitors are free to transform `node`.\r\n *   They can also transform `parent`.\r\n *\r\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\r\n *   descendants to be walked (which is a bug).\r\n *\r\n *   When adding or removing previous siblings of `node` (or next siblings, in\r\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\r\n *   sibling to traverse after `node` is traversed.\r\n *   Adding or removing next siblings of `node` (or previous siblings, in case\r\n *   of reverse) is handled as expected without needing to return a new `Index`.\r\n *\r\n *   Removing the children property of `parent` still results in them being\r\n *   traversed.\r\n * @param {Visited} node\r\n *   Found node.\r\n * @param {Visited extends Node ? number | null : never} index\r\n *   Index of `node` in `parent`.\r\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\r\n *   Parent of `node`.\r\n * @returns {VisitorResult}\r\n *   What to do next.\r\n *\r\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\r\n *   An `Action` is treated as a tuple of `[Action]`.\r\n *\r\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\r\n *   When the `Action` is `EXIT`, that action can be returned.\r\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\r\n */\n\n/**\r\n * Build a typed `Visitor` function from a node and all possible parents.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} Visited\r\n *   Node type.\r\n * @template {Parent} Ancestor\r\n *   Parent type.\r\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\r\n */\n\n/**\r\n * Build a typed `Visitor` function from a list of descendants and a test.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} Descendant\r\n *   Node type.\r\n * @template {Test} Check\r\n *   Test type.\r\n * @typedef {(\r\n *   BuildVisitorFromMatch<\r\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\r\n *     Extract<Descendant, Parent>\r\n *   >\r\n * )} BuildVisitorFromDescendants\r\n */\n\n/**\r\n * Build a typed `Visitor` function from a tree and a test.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} [Tree=Node]\r\n *   Node type.\r\n * @template {Test} [Check=string]\r\n *   Test type.\r\n * @typedef {(\r\n *   BuildVisitorFromDescendants<\r\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\r\n *     Check\r\n *   >\r\n * )} BuildVisitor\r\n */\n\nimport { visitParents } from 'unist-util-visit-parents';\n\n/**\r\n * Visit nodes.\r\n *\r\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\r\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\r\n *\r\n * You can choose for which nodes `visitor` is called by passing a `test`.\r\n * For complex tests, you should test yourself in `visitor`, as it will be\r\n * faster and will have improved type information.\r\n *\r\n * Walking the tree is an intensive task.\r\n * Make use of the return values of the visitor when possible.\r\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\r\n * to check if a node matches, and then perform different operations.\r\n *\r\n * You can change the tree.\r\n * See `Visitor` for more info.\r\n *\r\n * @param tree\r\n *   Tree to traverse.\r\n * @param test\r\n *   `unist-util-is`-compatible test\r\n * @param visitor\r\n *   Handle each node.\r\n * @param reverse\r\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\r\n * @returns\r\n *   Nothing.\r\n */\nexport const visit =\n/**\r\n * @type {(\r\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\r\n *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\r\n * )}\r\n */\n\n/**\r\n * @param {Node} tree\r\n * @param {Test} test\r\n * @param {Visitor} visitor\r\n * @param {boolean | null | undefined} [reverse]\r\n * @returns {void}\r\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n  visitParents(tree, test, overload, reverse);\n\n  /**\r\n   * @param {Node} node\r\n   * @param {Array<Parent>} parents\r\n   */\n  function overload(node, parents) {\n    const parent = parents[parents.length - 1];\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n  }\n};\nexport { CONTINUE, EXIT, SKIP } from 'unist-util-visit-parents';","map":{"version":3,"names":["visitParents","visit","tree","test","visitor","reverse","overload","node","parents","parent","length","children","indexOf","CONTINUE","EXIT","SKIP"],"sources":["C:/Users/saura/Desktop/AlgoDevFreaks/node_modules/unist-util-visit/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\r\n */\r\n\r\n/**\r\n * Check if `Child` can be a child of `Ancestor`.\r\n *\r\n * Returns the ancestor when `Child` can be a child of `Ancestor`, or returns\r\n * `never`.\r\n *\r\n * @template {Node} Ancestor\r\n *   Node type.\r\n * @template {Node} Child\r\n *   Node type.\r\n * @typedef {(\r\n *   Ancestor extends Parent\r\n *     ? Child extends Ancestor['children'][number]\r\n *       ? Ancestor\r\n *       : never\r\n *     : never\r\n * )} ParentsOf\r\n */\r\n\r\n/**\r\n * @template {Node} [Visited=Node]\r\n *   Visited node type.\r\n * @template {Parent} [Ancestor=Parent]\r\n *   Ancestor type.\r\n * @callback Visitor\r\n *   Handle a node (matching `test`, if given).\r\n *\r\n *   Visitors are free to transform `node`.\r\n *   They can also transform `parent`.\r\n *\r\n *   Replacing `node` itself, if `SKIP` is not returned, still causes its\r\n *   descendants to be walked (which is a bug).\r\n *\r\n *   When adding or removing previous siblings of `node` (or next siblings, in\r\n *   case of reverse), the `Visitor` should return a new `Index` to specify the\r\n *   sibling to traverse after `node` is traversed.\r\n *   Adding or removing next siblings of `node` (or previous siblings, in case\r\n *   of reverse) is handled as expected without needing to return a new `Index`.\r\n *\r\n *   Removing the children property of `parent` still results in them being\r\n *   traversed.\r\n * @param {Visited} node\r\n *   Found node.\r\n * @param {Visited extends Node ? number | null : never} index\r\n *   Index of `node` in `parent`.\r\n * @param {Ancestor extends Node ? Ancestor | null : never} parent\r\n *   Parent of `node`.\r\n * @returns {VisitorResult}\r\n *   What to do next.\r\n *\r\n *   An `Index` is treated as a tuple of `[CONTINUE, Index]`.\r\n *   An `Action` is treated as a tuple of `[Action]`.\r\n *\r\n *   Passing a tuple back only makes sense if the `Action` is `SKIP`.\r\n *   When the `Action` is `EXIT`, that action can be returned.\r\n *   When the `Action` is `CONTINUE`, `Index` can be returned.\r\n */\r\n\r\n/**\r\n * Build a typed `Visitor` function from a node and all possible parents.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} Visited\r\n *   Node type.\r\n * @template {Parent} Ancestor\r\n *   Parent type.\r\n * @typedef {Visitor<Visited, ParentsOf<Ancestor, Visited>>} BuildVisitorFromMatch\r\n */\r\n\r\n/**\r\n * Build a typed `Visitor` function from a list of descendants and a test.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} Descendant\r\n *   Node type.\r\n * @template {Test} Check\r\n *   Test type.\r\n * @typedef {(\r\n *   BuildVisitorFromMatch<\r\n *     import('unist-util-visit-parents/complex-types.js').Matches<Descendant, Check>,\r\n *     Extract<Descendant, Parent>\r\n *   >\r\n * )} BuildVisitorFromDescendants\r\n */\r\n\r\n/**\r\n * Build a typed `Visitor` function from a tree and a test.\r\n *\r\n * It will infer which values are passed as `node` and which as `parent`.\r\n *\r\n * @template {Node} [Tree=Node]\r\n *   Node type.\r\n * @template {Test} [Check=string]\r\n *   Test type.\r\n * @typedef {(\r\n *   BuildVisitorFromDescendants<\r\n *     import('unist-util-visit-parents/complex-types.js').InclusiveDescendant<Tree>,\r\n *     Check\r\n *   >\r\n * )} BuildVisitor\r\n */\r\n\r\nimport {visitParents} from 'unist-util-visit-parents'\r\n\r\n/**\r\n * Visit nodes.\r\n *\r\n * This algorithm performs *depth-first* *tree traversal* in *preorder*\r\n * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).\r\n *\r\n * You can choose for which nodes `visitor` is called by passing a `test`.\r\n * For complex tests, you should test yourself in `visitor`, as it will be\r\n * faster and will have improved type information.\r\n *\r\n * Walking the tree is an intensive task.\r\n * Make use of the return values of the visitor when possible.\r\n * Instead of walking a tree multiple times, walk it once, use `unist-util-is`\r\n * to check if a node matches, and then perform different operations.\r\n *\r\n * You can change the tree.\r\n * See `Visitor` for more info.\r\n *\r\n * @param tree\r\n *   Tree to traverse.\r\n * @param test\r\n *   `unist-util-is`-compatible test\r\n * @param visitor\r\n *   Handle each node.\r\n * @param reverse\r\n *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).\r\n * @returns\r\n *   Nothing.\r\n */\r\nexport const visit =\r\n  /**\r\n   * @type {(\r\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\r\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Node} tree\r\n     * @param {Test} test\r\n     * @param {Visitor} visitor\r\n     * @param {boolean | null | undefined} [reverse]\r\n     * @returns {void}\r\n     */\r\n    function (tree, test, visitor, reverse) {\r\n      if (typeof test === 'function' && typeof visitor !== 'function') {\r\n        reverse = visitor\r\n        visitor = test\r\n        test = null\r\n      }\r\n\r\n      visitParents(tree, test, overload, reverse)\r\n\r\n      /**\r\n       * @param {Node} node\r\n       * @param {Array<Parent>} parents\r\n       */\r\n      function overload(node, parents) {\r\n        const parent = parents[parents.length - 1]\r\n        return visitor(\r\n          node,\r\n          parent ? parent.children.indexOf(node) : null,\r\n          parent\r\n        )\r\n      }\r\n    }\r\n  )\r\n\r\nexport {CONTINUE, EXIT, SKIP} from 'unist-util-visit-parents'\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,YAAY,QAAO,0BAA0B;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK;AAChB;AACF;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACI,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACtC,IAAI,OAAOF,IAAI,KAAK,UAAU,IAAI,OAAOC,OAAO,KAAK,UAAU,EAAE;IAC/DC,OAAO,GAAGD,OAAO;IACjBA,OAAO,GAAGD,IAAI;IACdA,IAAI,GAAG,IAAI;EACb;EAEAH,YAAY,CAACE,IAAI,EAAEC,IAAI,EAAEG,QAAQ,EAAED,OAAO,CAAC;;EAE3C;AACN;AACA;AACA;EACM,SAASC,QAAQA,CAACC,IAAI,EAAEC,OAAO,EAAE;IAC/B,MAAMC,MAAM,GAAGD,OAAO,CAACA,OAAO,CAACE,MAAM,GAAG,CAAC,CAAC;IAC1C,OAAON,OAAO,CACZG,IAAI,EACJE,MAAM,GAAGA,MAAM,CAACE,QAAQ,CAACC,OAAO,CAACL,IAAI,CAAC,GAAG,IAAI,EAC7CE,MACF,CAAC;EACH;AACF,CACD;AAEH,SAAQI,QAAQ,EAAEC,IAAI,EAAEC,IAAI,QAAO,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}