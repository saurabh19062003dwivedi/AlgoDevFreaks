{"ast":null,"code":"/**\r\n * @typedef {import('hast').Content} HastContent\r\n * @typedef {import('hast').Root} HastRoot\r\n *\r\n * @typedef {import('mdast').Content} MdastContent\r\n * @typedef {import('mdast').Root} MdastRoot\r\n *\r\n * @typedef {import('./state.js').Options} Options\r\n */\n\n/**\r\n * @typedef {HastRoot | HastContent} HastNodes\r\n * @typedef {MdastRoot | MdastContent} MdastNodes\r\n */\n\nimport { footer } from './footer.js';\nimport { createState } from './state.js';\n\n/**\r\n * Transform mdast to hast.\r\n *\r\n * ##### Notes\r\n *\r\n * ###### HTML\r\n *\r\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\r\n * as semistandard `raw` nodes.\r\n * Most utilities ignore `raw` nodes but two notable ones don’t:\r\n *\r\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\r\n *     output the raw HTML.\r\n *     This is typically discouraged as noted by the option name but is useful\r\n *     if you completely trust authors\r\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\r\n *     into standard hast nodes (`element`, `text`, etc).\r\n *     This is a heavy task as it needs a full HTML parser, but it is the only\r\n *     way to support untrusted content\r\n *\r\n * ###### Footnotes\r\n *\r\n * Many options supported here relate to footnotes.\r\n * Footnotes are not specified by CommonMark, which we follow by default.\r\n * They are supported by GitHub, so footnotes can be enabled in markdown with\r\n * `mdast-util-gfm`.\r\n *\r\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\r\n * that explains footnotes, which is hidden for sighted users but shown to\r\n * assistive technology.\r\n * When your page is not in English, you must define translated values.\r\n *\r\n * Back references use ARIA attributes, but the section label itself uses a\r\n * heading that is hidden with an `sr-only` class.\r\n * To show it to sighted users, define different attributes in\r\n * `footnoteLabelProperties`.\r\n *\r\n * ###### Clobbering\r\n *\r\n * Footnotes introduces a problem, as it links footnote calls to footnote\r\n * definitions on the page through `id` attributes generated from user content,\r\n * which results in DOM clobbering.\r\n *\r\n * DOM clobbering is this:\r\n *\r\n * ```html\r\n * <p id=x></p>\r\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\r\n * ```\r\n *\r\n * Elements by their ID are made available by browsers on the `window` object,\r\n * which is a security risk.\r\n * Using a prefix solves this problem.\r\n *\r\n * More information on how to handle clobbering and the prefix is explained in\r\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\r\n *\r\n * ###### Unknown nodes\r\n *\r\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\r\n * The default behavior for unknown nodes is:\r\n *\r\n * *   when the node has a `value` (and doesn’t have `data.hName`,\r\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\r\n *     node\r\n * *   otherwise, create a `<div>` element (which could be changed with\r\n *     `data.hName`), with its children mapped from mdast to hast as well\r\n *\r\n * This behavior can be changed by passing an `unknownHandler`.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast tree.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {HastNodes | null | undefined}\r\n *   hast tree.\r\n */\n// To do: next major: always return a single `root`.\nexport function toHast(tree, options) {\n  const state = createState(tree, options);\n  const node = state.one(tree, null);\n  const foot = footer(state);\n  if (foot) {\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\n    // content.\n    // So assume `node` is a parent node.\n    node.children.push({\n      type: 'text',\n      value: '\\n'\n    }, foot);\n  }\n\n  // To do: next major: always return root?\n  return Array.isArray(node) ? {\n    type: 'root',\n    children: node\n  } : node;\n}","map":{"version":3,"names":["footer","createState","toHast","tree","options","state","node","one","foot","children","push","type","value","Array","isArray"],"sources":["C:/Users/saura/Desktop/AlgoDevFreaks/node_modules/mdast-util-to-hast/lib/index.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Content} HastContent\r\n * @typedef {import('hast').Root} HastRoot\r\n *\r\n * @typedef {import('mdast').Content} MdastContent\r\n * @typedef {import('mdast').Root} MdastRoot\r\n *\r\n * @typedef {import('./state.js').Options} Options\r\n */\r\n\r\n/**\r\n * @typedef {HastRoot | HastContent} HastNodes\r\n * @typedef {MdastRoot | MdastContent} MdastNodes\r\n */\r\n\r\nimport {footer} from './footer.js'\r\nimport {createState} from './state.js'\r\n\r\n/**\r\n * Transform mdast to hast.\r\n *\r\n * ##### Notes\r\n *\r\n * ###### HTML\r\n *\r\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\r\n * as semistandard `raw` nodes.\r\n * Most utilities ignore `raw` nodes but two notable ones don’t:\r\n *\r\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\r\n *     output the raw HTML.\r\n *     This is typically discouraged as noted by the option name but is useful\r\n *     if you completely trust authors\r\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\r\n *     into standard hast nodes (`element`, `text`, etc).\r\n *     This is a heavy task as it needs a full HTML parser, but it is the only\r\n *     way to support untrusted content\r\n *\r\n * ###### Footnotes\r\n *\r\n * Many options supported here relate to footnotes.\r\n * Footnotes are not specified by CommonMark, which we follow by default.\r\n * They are supported by GitHub, so footnotes can be enabled in markdown with\r\n * `mdast-util-gfm`.\r\n *\r\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\r\n * that explains footnotes, which is hidden for sighted users but shown to\r\n * assistive technology.\r\n * When your page is not in English, you must define translated values.\r\n *\r\n * Back references use ARIA attributes, but the section label itself uses a\r\n * heading that is hidden with an `sr-only` class.\r\n * To show it to sighted users, define different attributes in\r\n * `footnoteLabelProperties`.\r\n *\r\n * ###### Clobbering\r\n *\r\n * Footnotes introduces a problem, as it links footnote calls to footnote\r\n * definitions on the page through `id` attributes generated from user content,\r\n * which results in DOM clobbering.\r\n *\r\n * DOM clobbering is this:\r\n *\r\n * ```html\r\n * <p id=x></p>\r\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\r\n * ```\r\n *\r\n * Elements by their ID are made available by browsers on the `window` object,\r\n * which is a security risk.\r\n * Using a prefix solves this problem.\r\n *\r\n * More information on how to handle clobbering and the prefix is explained in\r\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\r\n *\r\n * ###### Unknown nodes\r\n *\r\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\r\n * The default behavior for unknown nodes is:\r\n *\r\n * *   when the node has a `value` (and doesn’t have `data.hName`,\r\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\r\n *     node\r\n * *   otherwise, create a `<div>` element (which could be changed with\r\n *     `data.hName`), with its children mapped from mdast to hast as well\r\n *\r\n * This behavior can be changed by passing an `unknownHandler`.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast tree.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {HastNodes | null | undefined}\r\n *   hast tree.\r\n */\r\n// To do: next major: always return a single `root`.\r\nexport function toHast(tree, options) {\r\n  const state = createState(tree, options)\r\n  const node = state.one(tree, null)\r\n  const foot = footer(state)\r\n\r\n  if (foot) {\r\n    // @ts-expect-error If there’s a footer, there were definitions, meaning block\r\n    // content.\r\n    // So assume `node` is a parent node.\r\n    node.children.push({type: 'text', value: '\\n'}, foot)\r\n  }\r\n\r\n  // To do: next major: always return root?\r\n  return Array.isArray(node) ? {type: 'root', children: node} : node\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAQA,MAAM,QAAO,aAAa;AAClC,SAAQC,WAAW,QAAO,YAAY;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACpC,MAAMC,KAAK,GAAGJ,WAAW,CAACE,IAAI,EAAEC,OAAO,CAAC;EACxC,MAAME,IAAI,GAAGD,KAAK,CAACE,GAAG,CAACJ,IAAI,EAAE,IAAI,CAAC;EAClC,MAAMK,IAAI,GAAGR,MAAM,CAACK,KAAK,CAAC;EAE1B,IAAIG,IAAI,EAAE;IACR;IACA;IACA;IACAF,IAAI,CAACG,QAAQ,CAACC,IAAI,CAAC;MAACC,IAAI,EAAE,MAAM;MAAEC,KAAK,EAAE;IAAI,CAAC,EAAEJ,IAAI,CAAC;EACvD;;EAEA;EACA,OAAOK,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC,GAAG;IAACK,IAAI,EAAE,MAAM;IAAEF,QAAQ,EAAEH;EAAI,CAAC,GAAGA,IAAI;AACpE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}