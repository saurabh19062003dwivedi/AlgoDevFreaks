{"ast":null,"code":"/**\r\n * @typedef {import('hast').Content} HastContent\r\n * @typedef {import('hast').Element} HastElement\r\n * @typedef {import('hast').ElementContent} HastElementContent\r\n * @typedef {import('hast').Properties} HastProperties\r\n * @typedef {import('hast').Root} HastRoot\r\n * @typedef {import('hast').Text} HastText\r\n *\r\n * @typedef {import('mdast').Content} MdastContent\r\n * @typedef {import('mdast').Definition} MdastDefinition\r\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\r\n * @typedef {import('mdast').Parent} MdastParent\r\n * @typedef {import('mdast').Root} MdastRoot\r\n */\n\n/**\r\n * @typedef {HastRoot | HastContent} HastNodes\r\n * @typedef {MdastRoot | MdastContent} MdastNodes\r\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\r\n *\r\n * @typedef EmbeddedHastFields\r\n *   hast fields.\r\n * @property {string | null | undefined} [hName]\r\n *   Generate a specific element with this tag name instead.\r\n * @property {HastProperties | null | undefined} [hProperties]\r\n *   Generate an element with these properties instead.\r\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\r\n *   Generate an element with this content instead.\r\n *\r\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\r\n *   mdast data with embedded hast fields.\r\n *\r\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\r\n *   mdast node with embedded hast data.\r\n *\r\n * @typedef PointLike\r\n *   Point-like value.\r\n * @property {number | null | undefined} [line]\r\n *   Line.\r\n * @property {number | null | undefined} [column]\r\n *   Column.\r\n * @property {number | null | undefined} [offset]\r\n *   Offset.\r\n *\r\n * @typedef PositionLike\r\n *   Position-like value.\r\n * @property {PointLike | null | undefined} [start]\r\n *   Point-like value.\r\n * @property {PointLike | null | undefined} [end]\r\n *   Point-like value.\r\n *\r\n * @callback Handler\r\n *   Handle a node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {any} node\r\n *   mdast node to handle.\r\n * @param {MdastParents | null | undefined} parent\r\n *   Parent of `node`.\r\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n *   hast node.\r\n *\r\n * @callback HFunctionProps\r\n *   Signature of `state` for when props are passed.\r\n * @param {MdastNodes | PositionLike | null | undefined} node\r\n *   mdast node or unist position.\r\n * @param {string} tagName\r\n *   HTML tag name.\r\n * @param {HastProperties} props\r\n *   Properties.\r\n * @param {Array<HastElementContent> | null | undefined} [children]\r\n *   hast content.\r\n * @returns {HastElement}\r\n *   Compiled element.\r\n *\r\n * @callback HFunctionNoProps\r\n *   Signature of `state` for when no props are passed.\r\n * @param {MdastNodes | PositionLike | null | undefined} node\r\n *   mdast node or unist position.\r\n * @param {string} tagName\r\n *   HTML tag name.\r\n * @param {Array<HastElementContent> | null | undefined} [children]\r\n *   hast content.\r\n * @returns {HastElement}\r\n *   Compiled element.\r\n *\r\n * @typedef HFields\r\n *   Info on `state`.\r\n * @property {boolean} dangerous\r\n *   Whether HTML is allowed.\r\n * @property {string} clobberPrefix\r\n *   Prefix to use to prevent DOM clobbering.\r\n * @property {string} footnoteLabel\r\n *   Label to use to introduce the footnote section.\r\n * @property {string} footnoteLabelTagName\r\n *   HTML used for the footnote label.\r\n * @property {HastProperties} footnoteLabelProperties\r\n *   Properties on the HTML tag used for the footnote label.\r\n * @property {string} footnoteBackLabel\r\n *   Label to use from backreferences back to their footnote call.\r\n * @property {(identifier: string) => MdastDefinition | null} definition\r\n *   Definition cache.\r\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\r\n *   Footnote definitions by their identifier.\r\n * @property {Array<string>} footnoteOrder\r\n *   Identifiers of order when footnote calls first appear in tree order.\r\n * @property {Record<string, number>} footnoteCounts\r\n *   Counts for how often the same footnote was called.\r\n * @property {Handlers} handlers\r\n *   Applied handlers.\r\n * @property {Handler} unknownHandler\r\n *   Handler for any none not in `passThrough` or otherwise handled.\r\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\r\n *   Copy a nodeâ€™s positional info.\r\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\r\n *   Honor the `data` of `from`, and generate an element instead of `node`.\r\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\r\n *   Transform an mdast node to hast.\r\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\r\n *   Transform the children of an mdast parent to hast.\r\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\r\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\r\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\r\n *   Like `state` but lower-level and usable on non-elements.\r\n *   Deprecated: use `patch` and `applyData`.\r\n * @property {Array<string>} passThrough\r\n *   List of node types to pass through untouched (except for their children).\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\r\n *   Whether to persist raw HTML in markdown in the hast tree.\r\n * @property {string | null | undefined} [clobberPrefix='user-content-']\r\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\r\n *   *clobbering*.\r\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\r\n *   Label to use from backreferences back to their footnote call (affects\r\n *   screen readers).\r\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\r\n *   Label to use for the footnotes section (affects screen readers).\r\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\r\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\r\n *   is always added as footnote calls use it with `aria-describedby` to\r\n *   provide an accessible label).\r\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\r\n *   Tag name to use for the footnote label.\r\n * @property {Handlers | null | undefined} [handlers]\r\n *   Extra handlers for nodes.\r\n * @property {Array<string> | null | undefined} [passThrough]\r\n *   List of custom mdast node types to pass through (keep) in hast (note that\r\n *   the node itself is passed, but eventual children are transformed).\r\n * @property {Handler | null | undefined} [unknownHandler]\r\n *   Handler for all unknown nodes.\r\n *\r\n * @typedef {Record<string, Handler>} Handlers\r\n *   Handle nodes.\r\n *\r\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\r\n *   Info passed around.\r\n */\n\nimport { visit } from 'unist-util-visit';\nimport { position, pointStart, pointEnd } from 'unist-util-position';\nimport { generated } from 'unist-util-generated';\nimport { definitions } from 'mdast-util-definitions';\nimport { handlers } from './handlers/index.js';\nconst own = {}.hasOwnProperty;\n\n/**\r\n * Create `state` from an mdast tree.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast node to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {State}\r\n *   `state` function.\r\n */\nexport function createState(tree, options) {\n  const settings = options || {};\n  const dangerous = settings.allowDangerousHtml || false;\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n  const footnoteById = {};\n\n  // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n  state.dangerous = dangerous;\n  // To do: next major: move to `state.options`.\n  state.clobberPrefix = settings.clobberPrefix === undefined || settings.clobberPrefix === null ? 'user-content-' : settings.clobberPrefix;\n  // To do: next major: move to `state.options`.\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes';\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2';\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  };\n  // To do: next major: move to `state.options`.\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content';\n  // To do: next major: move to `state.options`.\n  state.unknownHandler = settings.unknownHandler;\n  // To do: next major: move to `state.options`.\n  state.passThrough = settings.passThrough;\n  state.handlers = {\n    ...handlers,\n    ...settings.handlers\n  };\n\n  // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n  state.definition = definitions(tree);\n  state.footnoteById = footnoteById;\n  /** @type {Array<string>} */\n  state.footnoteOrder = [];\n  /** @type {Record<string, number>} */\n  state.footnoteCounts = {};\n  state.patch = patch;\n  state.applyData = applyData;\n  state.one = oneBound;\n  state.all = allBound;\n  state.wrap = wrap;\n  // To do: next major: remove `augment`.\n  state.augment = augment;\n  visit(tree, 'footnoteDefinition', definition => {\n    const id = String(definition.identifier).toUpperCase();\n\n    // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition;\n    }\n  });\n\n  // @ts-expect-error Hush, itâ€™s fine!\n  return state;\n\n  /**\r\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\r\n   *\r\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\r\n   * @param {HastElementContent} right\r\n   * @returns {HastElementContent}\r\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data;\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          };\n        }\n        right.tagName = data.hName;\n      }\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = {\n          ...right.properties,\n          ...data.hProperties\n        };\n      }\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren;\n      }\n    }\n    if (left) {\n      const ctx = 'type' in left ? left : {\n        position: left\n      };\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {\n          start: pointStart(ctx),\n          end: pointEnd(ctx)\n        };\n      }\n    }\n    return right;\n  }\n  /* c8 ignore stop */\n\n  /**\r\n   * Create an element for `node`.\r\n   *\r\n   * @type {HFunctionProps}\r\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props;\n      props = {};\n    }\n\n    // @ts-expect-error augmenting an element yields an element.\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    });\n  }\n  /* c8 ignore stop */\n\n  /**\r\n   * Transform an mdast node into a hast node.\r\n   *\r\n   * @param {MdastNodes} node\r\n   *   mdast node.\r\n   * @param {MdastParents | null | undefined} [parent]\r\n   *   Parent of `node`.\r\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n   *   Resulting hast node.\r\n   */\n  function oneBound(node, parent) {\n    // @ts-expect-error: thatâ€™s a state :)\n    return one(state, node, parent);\n  }\n\n  /**\r\n   * Transform the children of an mdast node into hast nodes.\r\n   *\r\n   * @param {MdastNodes} parent\r\n   *   mdast node to compile\r\n   * @returns {Array<HastElementContent>}\r\n   *   Resulting hast nodes.\r\n   */\n  function allBound(parent) {\n    // @ts-expect-error: thatâ€™s a state :)\n    return all(state, parent);\n  }\n}\n\n/**\r\n * Copy a nodeâ€™s positional info.\r\n *\r\n * @param {MdastNodes} from\r\n *   mdast node to copy from.\r\n * @param {HastNodes} to\r\n *   hast node to copy into.\r\n * @returns {void}\r\n *   Nothing.\r\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from);\n}\n\n/**\r\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\r\n *\r\n * @template {HastNodes} Type\r\n *   Node type.\r\n * @param {MdastNodes} from\r\n *   mdast node to use data from.\r\n * @param {Type} to\r\n *   hast node to change.\r\n * @returns {Type | HastElement}\r\n *   Nothing.\r\n */\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to;\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName;\n    const hChildren = from.data.hChildren;\n    const hProperties = from.data.hProperties;\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName;\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        };\n\n        // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n    if (result.type === 'element' && hProperties) {\n      result.properties = {\n        ...result.properties,\n        ...hProperties\n      };\n    }\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren;\n    }\n  }\n  return result;\n}\n\n/**\r\n * Transform an mdast node into a hast node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   mdast node.\r\n * @param {MdastParents | null | undefined} [parent]\r\n *   Parent of `node`.\r\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n *   Resulting hast node.\r\n */\n// To do: next major: do not expose, keep bound.\nexport function one(state, node, parent) {\n  const type = node && node.type;\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent);\n  }\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? {\n      ...node,\n      children: all(state, node)\n    } : node;\n  }\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent);\n  }\n  return defaultUnknownHandler(state, node);\n}\n\n/**\r\n * Transform the children of an mdast node into hast nodes.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} parent\r\n *   mdast node to compile\r\n * @returns {Array<HastElementContent>}\r\n *   Resulting hast nodes.\r\n */\n// To do: next major: do not expose, keep bound.\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = [];\n  if ('children' in parent) {\n    const nodes = parent.children;\n    let index = -1;\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent);\n\n      // To do: see if we van clean this? Can we merge texts?\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '');\n          }\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0];\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '');\n            }\n          }\n        }\n        if (Array.isArray(result)) {\n          values.push(...result);\n        } else {\n          values.push(result);\n        }\n      }\n    }\n  }\n  return values;\n}\n\n/**\r\n * Transform an unknown node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   Unknown mdast node.\r\n * @returns {HastText | HastElement}\r\n *   Resulting hast node.\r\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {};\n  /** @type {HastText | HastElement} */\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\n    type: 'text',\n    value: node.value\n  } : {\n    type: 'element',\n    tagName: 'div',\n    properties: {},\n    children: all(state, node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n\n/**\r\n * Wrap `nodes` with line endings between each node.\r\n *\r\n * @template {HastContent} Type\r\n *   Node type.\r\n * @param {Array<Type>} nodes\r\n *   List of nodes to wrap.\r\n * @param {boolean | null | undefined} [loose=false]\r\n *   Whether to add line endings at start and end.\r\n * @returns {Array<Type | HastText>}\r\n *   Wrapped nodes.\r\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = [];\n  let index = -1;\n  if (loose) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n  while (++index < nodes.length) {\n    if (index) result.push({\n      type: 'text',\n      value: '\\n'\n    });\n    result.push(nodes[index]);\n  }\n  if (loose && nodes.length > 0) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n  return result;\n}","map":{"version":3,"names":["visit","position","pointStart","pointEnd","generated","definitions","handlers","own","hasOwnProperty","createState","tree","options","settings","dangerous","allowDangerousHtml","footnoteById","state","clobberPrefix","undefined","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","className","footnoteBackLabel","unknownHandler","passThrough","definition","footnoteOrder","footnoteCounts","patch","applyData","one","oneBound","all","allBound","wrap","augment","id","String","identifier","toUpperCase","call","left","right","data","hName","type","tagName","properties","children","hProperties","hChildren","ctx","start","end","node","props","Array","isArray","parent","from","to","result","Error","includes","defaultUnknownHandler","values","nodes","index","length","value","replace","head","push","loose"],"sources":["C:/Users/saura/Desktop/AlgoDevFreaks/node_modules/mdast-util-to-hast/lib/state.js"],"sourcesContent":["/**\r\n * @typedef {import('hast').Content} HastContent\r\n * @typedef {import('hast').Element} HastElement\r\n * @typedef {import('hast').ElementContent} HastElementContent\r\n * @typedef {import('hast').Properties} HastProperties\r\n * @typedef {import('hast').Root} HastRoot\r\n * @typedef {import('hast').Text} HastText\r\n *\r\n * @typedef {import('mdast').Content} MdastContent\r\n * @typedef {import('mdast').Definition} MdastDefinition\r\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\r\n * @typedef {import('mdast').Parent} MdastParent\r\n * @typedef {import('mdast').Root} MdastRoot\r\n */\r\n\r\n/**\r\n * @typedef {HastRoot | HastContent} HastNodes\r\n * @typedef {MdastRoot | MdastContent} MdastNodes\r\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\r\n *\r\n * @typedef EmbeddedHastFields\r\n *   hast fields.\r\n * @property {string | null | undefined} [hName]\r\n *   Generate a specific element with this tag name instead.\r\n * @property {HastProperties | null | undefined} [hProperties]\r\n *   Generate an element with these properties instead.\r\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\r\n *   Generate an element with this content instead.\r\n *\r\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\r\n *   mdast data with embedded hast fields.\r\n *\r\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\r\n *   mdast node with embedded hast data.\r\n *\r\n * @typedef PointLike\r\n *   Point-like value.\r\n * @property {number | null | undefined} [line]\r\n *   Line.\r\n * @property {number | null | undefined} [column]\r\n *   Column.\r\n * @property {number | null | undefined} [offset]\r\n *   Offset.\r\n *\r\n * @typedef PositionLike\r\n *   Position-like value.\r\n * @property {PointLike | null | undefined} [start]\r\n *   Point-like value.\r\n * @property {PointLike | null | undefined} [end]\r\n *   Point-like value.\r\n *\r\n * @callback Handler\r\n *   Handle a node.\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {any} node\r\n *   mdast node to handle.\r\n * @param {MdastParents | null | undefined} parent\r\n *   Parent of `node`.\r\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n *   hast node.\r\n *\r\n * @callback HFunctionProps\r\n *   Signature of `state` for when props are passed.\r\n * @param {MdastNodes | PositionLike | null | undefined} node\r\n *   mdast node or unist position.\r\n * @param {string} tagName\r\n *   HTML tag name.\r\n * @param {HastProperties} props\r\n *   Properties.\r\n * @param {Array<HastElementContent> | null | undefined} [children]\r\n *   hast content.\r\n * @returns {HastElement}\r\n *   Compiled element.\r\n *\r\n * @callback HFunctionNoProps\r\n *   Signature of `state` for when no props are passed.\r\n * @param {MdastNodes | PositionLike | null | undefined} node\r\n *   mdast node or unist position.\r\n * @param {string} tagName\r\n *   HTML tag name.\r\n * @param {Array<HastElementContent> | null | undefined} [children]\r\n *   hast content.\r\n * @returns {HastElement}\r\n *   Compiled element.\r\n *\r\n * @typedef HFields\r\n *   Info on `state`.\r\n * @property {boolean} dangerous\r\n *   Whether HTML is allowed.\r\n * @property {string} clobberPrefix\r\n *   Prefix to use to prevent DOM clobbering.\r\n * @property {string} footnoteLabel\r\n *   Label to use to introduce the footnote section.\r\n * @property {string} footnoteLabelTagName\r\n *   HTML used for the footnote label.\r\n * @property {HastProperties} footnoteLabelProperties\r\n *   Properties on the HTML tag used for the footnote label.\r\n * @property {string} footnoteBackLabel\r\n *   Label to use from backreferences back to their footnote call.\r\n * @property {(identifier: string) => MdastDefinition | null} definition\r\n *   Definition cache.\r\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\r\n *   Footnote definitions by their identifier.\r\n * @property {Array<string>} footnoteOrder\r\n *   Identifiers of order when footnote calls first appear in tree order.\r\n * @property {Record<string, number>} footnoteCounts\r\n *   Counts for how often the same footnote was called.\r\n * @property {Handlers} handlers\r\n *   Applied handlers.\r\n * @property {Handler} unknownHandler\r\n *   Handler for any none not in `passThrough` or otherwise handled.\r\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\r\n *   Copy a nodeâ€™s positional info.\r\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\r\n *   Honor the `data` of `from`, and generate an element instead of `node`.\r\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\r\n *   Transform an mdast node to hast.\r\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\r\n *   Transform the children of an mdast parent to hast.\r\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\r\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\r\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\r\n *   Like `state` but lower-level and usable on non-elements.\r\n *   Deprecated: use `patch` and `applyData`.\r\n * @property {Array<string>} passThrough\r\n *   List of node types to pass through untouched (except for their children).\r\n *\r\n * @typedef Options\r\n *   Configuration (optional).\r\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\r\n *   Whether to persist raw HTML in markdown in the hast tree.\r\n * @property {string | null | undefined} [clobberPrefix='user-content-']\r\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\r\n *   *clobbering*.\r\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\r\n *   Label to use from backreferences back to their footnote call (affects\r\n *   screen readers).\r\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\r\n *   Label to use for the footnotes section (affects screen readers).\r\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\r\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\r\n *   is always added as footnote calls use it with `aria-describedby` to\r\n *   provide an accessible label).\r\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\r\n *   Tag name to use for the footnote label.\r\n * @property {Handlers | null | undefined} [handlers]\r\n *   Extra handlers for nodes.\r\n * @property {Array<string> | null | undefined} [passThrough]\r\n *   List of custom mdast node types to pass through (keep) in hast (note that\r\n *   the node itself is passed, but eventual children are transformed).\r\n * @property {Handler | null | undefined} [unknownHandler]\r\n *   Handler for all unknown nodes.\r\n *\r\n * @typedef {Record<string, Handler>} Handlers\r\n *   Handle nodes.\r\n *\r\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\r\n *   Info passed around.\r\n */\r\n\r\nimport {visit} from 'unist-util-visit'\r\nimport {position, pointStart, pointEnd} from 'unist-util-position'\r\nimport {generated} from 'unist-util-generated'\r\nimport {definitions} from 'mdast-util-definitions'\r\nimport {handlers} from './handlers/index.js'\r\n\r\nconst own = {}.hasOwnProperty\r\n\r\n/**\r\n * Create `state` from an mdast tree.\r\n *\r\n * @param {MdastNodes} tree\r\n *   mdast node to transform.\r\n * @param {Options | null | undefined} [options]\r\n *   Configuration.\r\n * @returns {State}\r\n *   `state` function.\r\n */\r\nexport function createState(tree, options) {\r\n  const settings = options || {}\r\n  const dangerous = settings.allowDangerousHtml || false\r\n  /** @type {Record<string, MdastFootnoteDefinition>} */\r\n  const footnoteById = {}\r\n\r\n  // To do: next major: add `options` to state, remove:\r\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\r\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\r\n  // `unknownHandler`.\r\n\r\n  // To do: next major: move to `state.options.allowDangerousHtml`.\r\n  state.dangerous = dangerous\r\n  // To do: next major: move to `state.options`.\r\n  state.clobberPrefix =\r\n    settings.clobberPrefix === undefined || settings.clobberPrefix === null\r\n      ? 'user-content-'\r\n      : settings.clobberPrefix\r\n  // To do: next major: move to `state.options`.\r\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'\r\n  // To do: next major: move to `state.options`.\r\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'\r\n  // To do: next major: move to `state.options`.\r\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\r\n    className: ['sr-only']\r\n  }\r\n  // To do: next major: move to `state.options`.\r\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'\r\n  // To do: next major: move to `state.options`.\r\n  state.unknownHandler = settings.unknownHandler\r\n  // To do: next major: move to `state.options`.\r\n  state.passThrough = settings.passThrough\r\n\r\n  state.handlers = {...handlers, ...settings.handlers}\r\n\r\n  // To do: next major: replace utility with `definitionById` object, so we\r\n  // only walk once (as we need footnotes too).\r\n  state.definition = definitions(tree)\r\n  state.footnoteById = footnoteById\r\n  /** @type {Array<string>} */\r\n  state.footnoteOrder = []\r\n  /** @type {Record<string, number>} */\r\n  state.footnoteCounts = {}\r\n\r\n  state.patch = patch\r\n  state.applyData = applyData\r\n  state.one = oneBound\r\n  state.all = allBound\r\n  state.wrap = wrap\r\n  // To do: next major: remove `augment`.\r\n  state.augment = augment\r\n\r\n  visit(tree, 'footnoteDefinition', (definition) => {\r\n    const id = String(definition.identifier).toUpperCase()\r\n\r\n    // Mimick CM behavior of link definitions.\r\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\r\n    if (!own.call(footnoteById, id)) {\r\n      footnoteById[id] = definition\r\n    }\r\n  })\r\n\r\n  // @ts-expect-error Hush, itâ€™s fine!\r\n  return state\r\n\r\n  /**\r\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\r\n   *\r\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\r\n   * @param {HastElementContent} right\r\n   * @returns {HastElementContent}\r\n   */\r\n  /* c8 ignore start */\r\n  // To do: next major: remove.\r\n  function augment(left, right) {\r\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\r\n    if (left && 'data' in left && left.data) {\r\n      /** @type {MdastData} */\r\n      const data = left.data\r\n\r\n      if (data.hName) {\r\n        if (right.type !== 'element') {\r\n          right = {\r\n            type: 'element',\r\n            tagName: '',\r\n            properties: {},\r\n            children: []\r\n          }\r\n        }\r\n\r\n        right.tagName = data.hName\r\n      }\r\n\r\n      if (right.type === 'element' && data.hProperties) {\r\n        right.properties = {...right.properties, ...data.hProperties}\r\n      }\r\n\r\n      if ('children' in right && right.children && data.hChildren) {\r\n        right.children = data.hChildren\r\n      }\r\n    }\r\n\r\n    if (left) {\r\n      const ctx = 'type' in left ? left : {position: left}\r\n\r\n      if (!generated(ctx)) {\r\n        // @ts-expect-error: fine.\r\n        right.position = {start: pointStart(ctx), end: pointEnd(ctx)}\r\n      }\r\n    }\r\n\r\n    return right\r\n  }\r\n  /* c8 ignore stop */\r\n\r\n  /**\r\n   * Create an element for `node`.\r\n   *\r\n   * @type {HFunctionProps}\r\n   */\r\n  /* c8 ignore start */\r\n  // To do: next major: remove.\r\n  function state(node, tagName, props, children) {\r\n    if (Array.isArray(props)) {\r\n      children = props\r\n      props = {}\r\n    }\r\n\r\n    // @ts-expect-error augmenting an element yields an element.\r\n    return augment(node, {\r\n      type: 'element',\r\n      tagName,\r\n      properties: props || {},\r\n      children: children || []\r\n    })\r\n  }\r\n  /* c8 ignore stop */\r\n\r\n  /**\r\n   * Transform an mdast node into a hast node.\r\n   *\r\n   * @param {MdastNodes} node\r\n   *   mdast node.\r\n   * @param {MdastParents | null | undefined} [parent]\r\n   *   Parent of `node`.\r\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n   *   Resulting hast node.\r\n   */\r\n  function oneBound(node, parent) {\r\n    // @ts-expect-error: thatâ€™s a state :)\r\n    return one(state, node, parent)\r\n  }\r\n\r\n  /**\r\n   * Transform the children of an mdast node into hast nodes.\r\n   *\r\n   * @param {MdastNodes} parent\r\n   *   mdast node to compile\r\n   * @returns {Array<HastElementContent>}\r\n   *   Resulting hast nodes.\r\n   */\r\n  function allBound(parent) {\r\n    // @ts-expect-error: thatâ€™s a state :)\r\n    return all(state, parent)\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a nodeâ€™s positional info.\r\n *\r\n * @param {MdastNodes} from\r\n *   mdast node to copy from.\r\n * @param {HastNodes} to\r\n *   hast node to copy into.\r\n * @returns {void}\r\n *   Nothing.\r\n */\r\nfunction patch(from, to) {\r\n  if (from.position) to.position = position(from)\r\n}\r\n\r\n/**\r\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\r\n *\r\n * @template {HastNodes} Type\r\n *   Node type.\r\n * @param {MdastNodes} from\r\n *   mdast node to use data from.\r\n * @param {Type} to\r\n *   hast node to change.\r\n * @returns {Type | HastElement}\r\n *   Nothing.\r\n */\r\nfunction applyData(from, to) {\r\n  /** @type {Type | HastElement} */\r\n  let result = to\r\n\r\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\r\n  if (from && from.data) {\r\n    const hName = from.data.hName\r\n    const hChildren = from.data.hChildren\r\n    const hProperties = from.data.hProperties\r\n\r\n    if (typeof hName === 'string') {\r\n      // Transforming the node resulted in an element with a different name\r\n      // than wanted:\r\n      if (result.type === 'element') {\r\n        result.tagName = hName\r\n      }\r\n      // Transforming the node resulted in a non-element, which happens for\r\n      // raw, text, and root nodes (unless custom handlers are passed).\r\n      // The intent is likely to keep the content around (otherwise: pass\r\n      // `hChildren`).\r\n      else {\r\n        result = {\r\n          type: 'element',\r\n          tagName: hName,\r\n          properties: {},\r\n          children: []\r\n        }\r\n\r\n        // To do: next major: take the children from the `root`, or inject the\r\n        // raw/text/comment or so into the element?\r\n        // if ('children' in node) {\r\n        //   // @ts-expect-error: assume `children` are allowed in elements.\r\n        //   result.children = node.children\r\n        // } else {\r\n        //   // @ts-expect-error: assume `node` is allowed in elements.\r\n        //   result.children.push(node)\r\n        // }\r\n      }\r\n    }\r\n\r\n    if (result.type === 'element' && hProperties) {\r\n      result.properties = {...result.properties, ...hProperties}\r\n    }\r\n\r\n    if (\r\n      'children' in result &&\r\n      result.children &&\r\n      hChildren !== null &&\r\n      hChildren !== undefined\r\n    ) {\r\n      // @ts-expect-error: assume valid children are defined.\r\n      result.children = hChildren\r\n    }\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Transform an mdast node into a hast node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   mdast node.\r\n * @param {MdastParents | null | undefined} [parent]\r\n *   Parent of `node`.\r\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\r\n *   Resulting hast node.\r\n */\r\n// To do: next major: do not expose, keep bound.\r\nexport function one(state, node, parent) {\r\n  const type = node && node.type\r\n\r\n  // Fail on non-nodes.\r\n  if (!type) {\r\n    throw new Error('Expected node, got `' + node + '`')\r\n  }\r\n\r\n  if (own.call(state.handlers, type)) {\r\n    return state.handlers[type](state, node, parent)\r\n  }\r\n\r\n  if (state.passThrough && state.passThrough.includes(type)) {\r\n    // To do: next major: deep clone.\r\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\r\n    return 'children' in node ? {...node, children: all(state, node)} : node\r\n  }\r\n\r\n  if (state.unknownHandler) {\r\n    return state.unknownHandler(state, node, parent)\r\n  }\r\n\r\n  return defaultUnknownHandler(state, node)\r\n}\r\n\r\n/**\r\n * Transform the children of an mdast node into hast nodes.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} parent\r\n *   mdast node to compile\r\n * @returns {Array<HastElementContent>}\r\n *   Resulting hast nodes.\r\n */\r\n// To do: next major: do not expose, keep bound.\r\nexport function all(state, parent) {\r\n  /** @type {Array<HastElementContent>} */\r\n  const values = []\r\n\r\n  if ('children' in parent) {\r\n    const nodes = parent.children\r\n    let index = -1\r\n    while (++index < nodes.length) {\r\n      const result = one(state, nodes[index], parent)\r\n\r\n      // To do: see if we van clean this? Can we merge texts?\r\n      if (result) {\r\n        if (index && nodes[index - 1].type === 'break') {\r\n          if (!Array.isArray(result) && result.type === 'text') {\r\n            result.value = result.value.replace(/^\\s+/, '')\r\n          }\r\n\r\n          if (!Array.isArray(result) && result.type === 'element') {\r\n            const head = result.children[0]\r\n\r\n            if (head && head.type === 'text') {\r\n              head.value = head.value.replace(/^\\s+/, '')\r\n            }\r\n          }\r\n        }\r\n\r\n        if (Array.isArray(result)) {\r\n          values.push(...result)\r\n        } else {\r\n          values.push(result)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return values\r\n}\r\n\r\n/**\r\n * Transform an unknown node.\r\n *\r\n * @param {State} state\r\n *   Info passed around.\r\n * @param {MdastNodes} node\r\n *   Unknown mdast node.\r\n * @returns {HastText | HastElement}\r\n *   Resulting hast node.\r\n */\r\nfunction defaultUnknownHandler(state, node) {\r\n  const data = node.data || {}\r\n  /** @type {HastText | HastElement} */\r\n  const result =\r\n    'value' in node &&\r\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\r\n      ? {type: 'text', value: node.value}\r\n      : {\r\n          type: 'element',\r\n          tagName: 'div',\r\n          properties: {},\r\n          children: all(state, node)\r\n        }\r\n\r\n  state.patch(node, result)\r\n  return state.applyData(node, result)\r\n}\r\n\r\n/**\r\n * Wrap `nodes` with line endings between each node.\r\n *\r\n * @template {HastContent} Type\r\n *   Node type.\r\n * @param {Array<Type>} nodes\r\n *   List of nodes to wrap.\r\n * @param {boolean | null | undefined} [loose=false]\r\n *   Whether to add line endings at start and end.\r\n * @returns {Array<Type | HastText>}\r\n *   Wrapped nodes.\r\n */\r\nexport function wrap(nodes, loose) {\r\n  /** @type {Array<Type | HastText>} */\r\n  const result = []\r\n  let index = -1\r\n\r\n  if (loose) {\r\n    result.push({type: 'text', value: '\\n'})\r\n  }\r\n\r\n  while (++index < nodes.length) {\r\n    if (index) result.push({type: 'text', value: '\\n'})\r\n    result.push(nodes[index])\r\n  }\r\n\r\n  if (loose && nodes.length > 0) {\r\n    result.push({type: 'text', value: '\\n'})\r\n  }\r\n\r\n  return result\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,KAAK,QAAO,kBAAkB;AACtC,SAAQC,QAAQ,EAAEC,UAAU,EAAEC,QAAQ,QAAO,qBAAqB;AAClE,SAAQC,SAAS,QAAO,sBAAsB;AAC9C,SAAQC,WAAW,QAAO,wBAAwB;AAClD,SAAQC,QAAQ,QAAO,qBAAqB;AAE5C,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,IAAI,EAAEC,OAAO,EAAE;EACzC,MAAMC,QAAQ,GAAGD,OAAO,IAAI,CAAC,CAAC;EAC9B,MAAME,SAAS,GAAGD,QAAQ,CAACE,kBAAkB,IAAI,KAAK;EACtD;EACA,MAAMC,YAAY,GAAG,CAAC,CAAC;;EAEvB;EACA;EACA;EACA;;EAEA;EACAC,KAAK,CAACH,SAAS,GAAGA,SAAS;EAC3B;EACAG,KAAK,CAACC,aAAa,GACjBL,QAAQ,CAACK,aAAa,KAAKC,SAAS,IAAIN,QAAQ,CAACK,aAAa,KAAK,IAAI,GACnE,eAAe,GACfL,QAAQ,CAACK,aAAa;EAC5B;EACAD,KAAK,CAACG,aAAa,GAAGP,QAAQ,CAACO,aAAa,IAAI,WAAW;EAC3D;EACAH,KAAK,CAACI,oBAAoB,GAAGR,QAAQ,CAACQ,oBAAoB,IAAI,IAAI;EAClE;EACAJ,KAAK,CAACK,uBAAuB,GAAGT,QAAQ,CAACS,uBAAuB,IAAI;IAClEC,SAAS,EAAE,CAAC,SAAS;EACvB,CAAC;EACD;EACAN,KAAK,CAACO,iBAAiB,GAAGX,QAAQ,CAACW,iBAAiB,IAAI,iBAAiB;EACzE;EACAP,KAAK,CAACQ,cAAc,GAAGZ,QAAQ,CAACY,cAAc;EAC9C;EACAR,KAAK,CAACS,WAAW,GAAGb,QAAQ,CAACa,WAAW;EAExCT,KAAK,CAACV,QAAQ,GAAG;IAAC,GAAGA,QAAQ;IAAE,GAAGM,QAAQ,CAACN;EAAQ,CAAC;;EAEpD;EACA;EACAU,KAAK,CAACU,UAAU,GAAGrB,WAAW,CAACK,IAAI,CAAC;EACpCM,KAAK,CAACD,YAAY,GAAGA,YAAY;EACjC;EACAC,KAAK,CAACW,aAAa,GAAG,EAAE;EACxB;EACAX,KAAK,CAACY,cAAc,GAAG,CAAC,CAAC;EAEzBZ,KAAK,CAACa,KAAK,GAAGA,KAAK;EACnBb,KAAK,CAACc,SAAS,GAAGA,SAAS;EAC3Bd,KAAK,CAACe,GAAG,GAAGC,QAAQ;EACpBhB,KAAK,CAACiB,GAAG,GAAGC,QAAQ;EACpBlB,KAAK,CAACmB,IAAI,GAAGA,IAAI;EACjB;EACAnB,KAAK,CAACoB,OAAO,GAAGA,OAAO;EAEvBpC,KAAK,CAACU,IAAI,EAAE,oBAAoB,EAAGgB,UAAU,IAAK;IAChD,MAAMW,EAAE,GAAGC,MAAM,CAACZ,UAAU,CAACa,UAAU,CAAC,CAACC,WAAW,CAAC,CAAC;;IAEtD;IACA;IACA,IAAI,CAACjC,GAAG,CAACkC,IAAI,CAAC1B,YAAY,EAAEsB,EAAE,CAAC,EAAE;MAC/BtB,YAAY,CAACsB,EAAE,CAAC,GAAGX,UAAU;IAC/B;EACF,CAAC,CAAC;;EAEF;EACA,OAAOV,KAAK;;EAEZ;AACF;AACA;AACA;AACA;AACA;AACA;EACE;EACA;EACA,SAASoB,OAAOA,CAACM,IAAI,EAAEC,KAAK,EAAE;IAC5B;IACA,IAAID,IAAI,IAAI,MAAM,IAAIA,IAAI,IAAIA,IAAI,CAACE,IAAI,EAAE;MACvC;MACA,MAAMA,IAAI,GAAGF,IAAI,CAACE,IAAI;MAEtB,IAAIA,IAAI,CAACC,KAAK,EAAE;QACd,IAAIF,KAAK,CAACG,IAAI,KAAK,SAAS,EAAE;UAC5BH,KAAK,GAAG;YACNG,IAAI,EAAE,SAAS;YACfC,OAAO,EAAE,EAAE;YACXC,UAAU,EAAE,CAAC,CAAC;YACdC,QAAQ,EAAE;UACZ,CAAC;QACH;QAEAN,KAAK,CAACI,OAAO,GAAGH,IAAI,CAACC,KAAK;MAC5B;MAEA,IAAIF,KAAK,CAACG,IAAI,KAAK,SAAS,IAAIF,IAAI,CAACM,WAAW,EAAE;QAChDP,KAAK,CAACK,UAAU,GAAG;UAAC,GAAGL,KAAK,CAACK,UAAU;UAAE,GAAGJ,IAAI,CAACM;QAAW,CAAC;MAC/D;MAEA,IAAI,UAAU,IAAIP,KAAK,IAAIA,KAAK,CAACM,QAAQ,IAAIL,IAAI,CAACO,SAAS,EAAE;QAC3DR,KAAK,CAACM,QAAQ,GAAGL,IAAI,CAACO,SAAS;MACjC;IACF;IAEA,IAAIT,IAAI,EAAE;MACR,MAAMU,GAAG,GAAG,MAAM,IAAIV,IAAI,GAAGA,IAAI,GAAG;QAACzC,QAAQ,EAAEyC;MAAI,CAAC;MAEpD,IAAI,CAACtC,SAAS,CAACgD,GAAG,CAAC,EAAE;QACnB;QACAT,KAAK,CAAC1C,QAAQ,GAAG;UAACoD,KAAK,EAAEnD,UAAU,CAACkD,GAAG,CAAC;UAAEE,GAAG,EAAEnD,QAAQ,CAACiD,GAAG;QAAC,CAAC;MAC/D;IACF;IAEA,OAAOT,KAAK;EACd;EACA;;EAEA;AACF;AACA;AACA;AACA;EACE;EACA;EACA,SAAS3B,KAAKA,CAACuC,IAAI,EAAER,OAAO,EAAES,KAAK,EAAEP,QAAQ,EAAE;IAC7C,IAAIQ,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxBP,QAAQ,GAAGO,KAAK;MAChBA,KAAK,GAAG,CAAC,CAAC;IACZ;;IAEA;IACA,OAAOpB,OAAO,CAACmB,IAAI,EAAE;MACnBT,IAAI,EAAE,SAAS;MACfC,OAAO;MACPC,UAAU,EAAEQ,KAAK,IAAI,CAAC,CAAC;MACvBP,QAAQ,EAAEA,QAAQ,IAAI;IACxB,CAAC,CAAC;EACJ;EACA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASjB,QAAQA,CAACuB,IAAI,EAAEI,MAAM,EAAE;IAC9B;IACA,OAAO5B,GAAG,CAACf,KAAK,EAAEuC,IAAI,EAAEI,MAAM,CAAC;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,SAASzB,QAAQA,CAACyB,MAAM,EAAE;IACxB;IACA,OAAO1B,GAAG,CAACjB,KAAK,EAAE2C,MAAM,CAAC;EAC3B;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9B,KAAKA,CAAC+B,IAAI,EAAEC,EAAE,EAAE;EACvB,IAAID,IAAI,CAAC3D,QAAQ,EAAE4D,EAAE,CAAC5D,QAAQ,GAAGA,QAAQ,CAAC2D,IAAI,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9B,SAASA,CAAC8B,IAAI,EAAEC,EAAE,EAAE;EAC3B;EACA,IAAIC,MAAM,GAAGD,EAAE;;EAEf;EACA,IAAID,IAAI,IAAIA,IAAI,CAAChB,IAAI,EAAE;IACrB,MAAMC,KAAK,GAAGe,IAAI,CAAChB,IAAI,CAACC,KAAK;IAC7B,MAAMM,SAAS,GAAGS,IAAI,CAAChB,IAAI,CAACO,SAAS;IACrC,MAAMD,WAAW,GAAGU,IAAI,CAAChB,IAAI,CAACM,WAAW;IAEzC,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;MAC7B;MACA;MACA,IAAIiB,MAAM,CAAChB,IAAI,KAAK,SAAS,EAAE;QAC7BgB,MAAM,CAACf,OAAO,GAAGF,KAAK;MACxB;MACA;MACA;MACA;MACA;MAAA,KACK;QACHiB,MAAM,GAAG;UACPhB,IAAI,EAAE,SAAS;UACfC,OAAO,EAAEF,KAAK;UACdG,UAAU,EAAE,CAAC,CAAC;UACdC,QAAQ,EAAE;QACZ,CAAC;;QAED;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;MACF;IACF;IAEA,IAAIa,MAAM,CAAChB,IAAI,KAAK,SAAS,IAAII,WAAW,EAAE;MAC5CY,MAAM,CAACd,UAAU,GAAG;QAAC,GAAGc,MAAM,CAACd,UAAU;QAAE,GAAGE;MAAW,CAAC;IAC5D;IAEA,IACE,UAAU,IAAIY,MAAM,IACpBA,MAAM,CAACb,QAAQ,IACfE,SAAS,KAAK,IAAI,IAClBA,SAAS,KAAKjC,SAAS,EACvB;MACA;MACA4C,MAAM,CAACb,QAAQ,GAAGE,SAAS;IAC7B;EACF;EAEA,OAAOW,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS/B,GAAGA,CAACf,KAAK,EAAEuC,IAAI,EAAEI,MAAM,EAAE;EACvC,MAAMb,IAAI,GAAGS,IAAI,IAAIA,IAAI,CAACT,IAAI;;EAE9B;EACA,IAAI,CAACA,IAAI,EAAE;IACT,MAAM,IAAIiB,KAAK,CAAC,sBAAsB,GAAGR,IAAI,GAAG,GAAG,CAAC;EACtD;EAEA,IAAIhD,GAAG,CAACkC,IAAI,CAACzB,KAAK,CAACV,QAAQ,EAAEwC,IAAI,CAAC,EAAE;IAClC,OAAO9B,KAAK,CAACV,QAAQ,CAACwC,IAAI,CAAC,CAAC9B,KAAK,EAAEuC,IAAI,EAAEI,MAAM,CAAC;EAClD;EAEA,IAAI3C,KAAK,CAACS,WAAW,IAAIT,KAAK,CAACS,WAAW,CAACuC,QAAQ,CAAClB,IAAI,CAAC,EAAE;IACzD;IACA;IACA,OAAO,UAAU,IAAIS,IAAI,GAAG;MAAC,GAAGA,IAAI;MAAEN,QAAQ,EAAEhB,GAAG,CAACjB,KAAK,EAAEuC,IAAI;IAAC,CAAC,GAAGA,IAAI;EAC1E;EAEA,IAAIvC,KAAK,CAACQ,cAAc,EAAE;IACxB,OAAOR,KAAK,CAACQ,cAAc,CAACR,KAAK,EAAEuC,IAAI,EAAEI,MAAM,CAAC;EAClD;EAEA,OAAOM,qBAAqB,CAACjD,KAAK,EAAEuC,IAAI,CAAC;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAStB,GAAGA,CAACjB,KAAK,EAAE2C,MAAM,EAAE;EACjC;EACA,MAAMO,MAAM,GAAG,EAAE;EAEjB,IAAI,UAAU,IAAIP,MAAM,EAAE;IACxB,MAAMQ,KAAK,GAAGR,MAAM,CAACV,QAAQ;IAC7B,IAAImB,KAAK,GAAG,CAAC,CAAC;IACd,OAAO,EAAEA,KAAK,GAAGD,KAAK,CAACE,MAAM,EAAE;MAC7B,MAAMP,MAAM,GAAG/B,GAAG,CAACf,KAAK,EAAEmD,KAAK,CAACC,KAAK,CAAC,EAAET,MAAM,CAAC;;MAE/C;MACA,IAAIG,MAAM,EAAE;QACV,IAAIM,KAAK,IAAID,KAAK,CAACC,KAAK,GAAG,CAAC,CAAC,CAACtB,IAAI,KAAK,OAAO,EAAE;UAC9C,IAAI,CAACW,KAAK,CAACC,OAAO,CAACI,MAAM,CAAC,IAAIA,MAAM,CAAChB,IAAI,KAAK,MAAM,EAAE;YACpDgB,MAAM,CAACQ,KAAK,GAAGR,MAAM,CAACQ,KAAK,CAACC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;UACjD;UAEA,IAAI,CAACd,KAAK,CAACC,OAAO,CAACI,MAAM,CAAC,IAAIA,MAAM,CAAChB,IAAI,KAAK,SAAS,EAAE;YACvD,MAAM0B,IAAI,GAAGV,MAAM,CAACb,QAAQ,CAAC,CAAC,CAAC;YAE/B,IAAIuB,IAAI,IAAIA,IAAI,CAAC1B,IAAI,KAAK,MAAM,EAAE;cAChC0B,IAAI,CAACF,KAAK,GAAGE,IAAI,CAACF,KAAK,CAACC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC;YAC7C;UACF;QACF;QAEA,IAAId,KAAK,CAACC,OAAO,CAACI,MAAM,CAAC,EAAE;UACzBI,MAAM,CAACO,IAAI,CAAC,GAAGX,MAAM,CAAC;QACxB,CAAC,MAAM;UACLI,MAAM,CAACO,IAAI,CAACX,MAAM,CAAC;QACrB;MACF;IACF;EACF;EAEA,OAAOI,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,qBAAqBA,CAACjD,KAAK,EAAEuC,IAAI,EAAE;EAC1C,MAAMX,IAAI,GAAGW,IAAI,CAACX,IAAI,IAAI,CAAC,CAAC;EAC5B;EACA,MAAMkB,MAAM,GACV,OAAO,IAAIP,IAAI,IACf,EAAEhD,GAAG,CAACkC,IAAI,CAACG,IAAI,EAAE,aAAa,CAAC,IAAIrC,GAAG,CAACkC,IAAI,CAACG,IAAI,EAAE,WAAW,CAAC,CAAC,GAC3D;IAACE,IAAI,EAAE,MAAM;IAAEwB,KAAK,EAAEf,IAAI,CAACe;EAAK,CAAC,GACjC;IACExB,IAAI,EAAE,SAAS;IACfC,OAAO,EAAE,KAAK;IACdC,UAAU,EAAE,CAAC,CAAC;IACdC,QAAQ,EAAEhB,GAAG,CAACjB,KAAK,EAAEuC,IAAI;EAC3B,CAAC;EAEPvC,KAAK,CAACa,KAAK,CAAC0B,IAAI,EAAEO,MAAM,CAAC;EACzB,OAAO9C,KAAK,CAACc,SAAS,CAACyB,IAAI,EAAEO,MAAM,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS3B,IAAIA,CAACgC,KAAK,EAAEO,KAAK,EAAE;EACjC;EACA,MAAMZ,MAAM,GAAG,EAAE;EACjB,IAAIM,KAAK,GAAG,CAAC,CAAC;EAEd,IAAIM,KAAK,EAAE;IACTZ,MAAM,CAACW,IAAI,CAAC;MAAC3B,IAAI,EAAE,MAAM;MAAEwB,KAAK,EAAE;IAAI,CAAC,CAAC;EAC1C;EAEA,OAAO,EAAEF,KAAK,GAAGD,KAAK,CAACE,MAAM,EAAE;IAC7B,IAAID,KAAK,EAAEN,MAAM,CAACW,IAAI,CAAC;MAAC3B,IAAI,EAAE,MAAM;MAAEwB,KAAK,EAAE;IAAI,CAAC,CAAC;IACnDR,MAAM,CAACW,IAAI,CAACN,KAAK,CAACC,KAAK,CAAC,CAAC;EAC3B;EAEA,IAAIM,KAAK,IAAIP,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;IAC7BP,MAAM,CAACW,IAAI,CAAC;MAAC3B,IAAI,EAAE,MAAM;MAAEwB,KAAK,EAAE;IAAI,CAAC,CAAC;EAC1C;EAEA,OAAOR,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}